{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hp\\\\Desktop\\\\Projects\\\\Sorting-Sight-main\\\\src\\\\Algorithms\\\\MergeSort.js\";\nimport React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst MergeSort = nums => {\n  // initial trace\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n\n      k++;\n    }\n\n    ;\n\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    ;\n\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    ;\n    left.length = 0;\n    right.length = 0;\n  }\n\n  ;\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n\n    if (length < 2) {\n      // original = []\n      if (length < 1) {\n        console.log('length less than 1');\n        console.log(original);\n        return original;\n      } else {\n        // original = [x]\n        console.log('length equals 1');\n        console.log([original[start]]);\n        return [original[start]];\n      }\n\n      ;\n    }\n\n    ;\n    const midPoint = Math.floor((start + end) / 2); // visualize first half\n\n    addToTrace(trace, original, [], [...Array(midPoint - start).keys()].map(i => i + start));\n    recursiveMergeSort(original, start, midPoint); // visualize second half\n\n    addToTrace(trace, original, [], [...Array(end - midPoint).keys()].map(i => i + midPoint));\n    recursiveMergeSort(original, midPoint, end);\n    console.log(`trace before merge`);\n    console.log(trace);\n    merge(original, start, midPoint, end);\n  }\n\n  ;\n  recursiveMergeSort(nums, 0, nums.length); // visualize - mark all elements sorted\n\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  console.log(`trace after merge`);\n  console.log(trace);\n  return trace;\n};\n\n_c = MergeSort;\nexport const MergeSortKey = createKey('Call Merge Sort', null, 'Overwrite from axillary array');\nexport const MergeSortDesc = {\n  title: 'Merge Sort',\n  description: /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: [/*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"https://en.wikipedia.org/wiki/Merge_sort\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"Merge Sort\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 96,\n        columnNumber: 13\n      }, this), ' ', \"is an efficient, stable sorting algorith that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n      children: [/*#__PURE__*/_jsxDEV(\"li\", {\n        children: [\"Divide the unsorted list into \", /*#__PURE__*/_jsxDEV(\"em\", {\n          children: \"n\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 107,\n          columnNumber: 43\n        }, this), \" sublists, each containing one element (a list of one element is considered sorted)\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 106,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: \"Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 111,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 105,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 94,\n    columnNumber: 9\n  }, this),\n  worstCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 11\n    }, this), \"*log(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 26\n    }, this), \"))\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 118,\n    columnNumber: 9\n  }, this),\n  avgCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 11\n    }, this), \"*log(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 26\n    }, this), \"))\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 123,\n    columnNumber: 9\n  }, this),\n  bestCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 11\n    }, this), \"*log(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 26\n    }, this), \"))\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 128,\n    columnNumber: 9\n  }, this),\n  space: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 11\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 133,\n    columnNumber: 9\n  }, this)\n};\nexport default MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"sources":["C:/Users/hp/Desktop/Projects/Sorting-Sight-main/src/Algorithms/MergeSort.js"],"names":["React","newTrace","addToTrace","createKey","MergeSort","nums","trace","merge","original","start","mid","end","left","slice","right","i","j","k","length","recursiveMergeSort","console","log","midPoint","Math","floor","Array","keys","map","MergeSortKey","MergeSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = (nums) => {\n    // initial trace\n    const trace = newTrace(nums);\n\n    function merge(original, start, mid, end) {\n        const left = original.slice(start, mid);\n        const right = original.slice(mid, end);\n        let i = 0;\n        let j = 0;\n        let k = 0;\n        while (i < left.length && j < right.length) {\n            if (left[i] <= right[j]) {\n                addToTrace(trace, original, [], [], [], [k + start]);\n                original[k + start] = left[i];\n                i++;\n                addToTrace(trace, original, [], [], [], [k + start]);\n            } else {\n                addToTrace(trace, original, [], [], [], [k + start]);\n                original[k + start] = right[j];\n                j++;\n                addToTrace(trace, original, [], [], [], [k + start]);\n            }\n            k++;\n        };\n\n        while (i < left.length) {\n            addToTrace(trace, original, [], [], [], [k + start]);\n            original[k + start] = left[i];\n            i++;\n            k++;\n            addToTrace(trace, original, [], [], [], [k + start]);\n        };\n\n        while (j < right.length) {\n            addToTrace(trace, original, [], [], [], [k + start]);\n            original[k + start] = right[j];\n            j++;\n            k++;\n            addToTrace(trace, original, [], [], [], [k + start]);\n        };\n\n        left.length = 0;\n        right.length = 0;\n    };\n\n    function recursiveMergeSort(original, start, end) {\n        const length = end - start;\n        if (length < 2) {\n            // original = []\n            if (length < 1) {\n                console.log('length less than 1');\n                console.log(original);\n                return original;\n            } else {\n                // original = [x]\n                console.log('length equals 1');\n                console.log([original[start]]);\n                return [original[start]];\n            };\n        };\n\n        const midPoint = Math.floor((start + end) / 2);\n\n        // visualize first half\n        addToTrace(trace, original, [], [...Array(midPoint - start).keys()].map((i) => i + start));\n        recursiveMergeSort(original, start, midPoint);\n\n        // visualize second half\n        addToTrace(trace, original, [], [...Array(end - midPoint).keys()].map((i) => i + midPoint));\n        recursiveMergeSort(original, midPoint, end);\n\n        console.log(`trace before merge`);\n        console.log(trace);\n        merge(original, start, midPoint, end);\n    };\n\n    recursiveMergeSort(nums, 0, nums.length);\n\n    // visualize - mark all elements sorted\n    addToTrace(trace, nums, [...Array(nums.length).keys()]);\n    console.log(`trace after merge`);\n    console.log(trace);\n    return trace;\n};\n\nexport const MergeSortKey = createKey('Call Merge Sort', null, 'Overwrite from axillary array');\n\nexport const MergeSortDesc = {\n    title: 'Merge Sort',\n    description: (\n        <div>\n        <p>\n            <a\n            href=\"https://en.wikipedia.org/wiki/Merge_sort\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            >\n            Merge Sort\n            </a>{' '}\n            is an efficient, stable sorting algorith that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\n        </p>\n        <ol>\n            <li>\n            Divide the unsorted list into <em>n</em> sublists, each\n            containing one element (a list of one element is considered\n            sorted)\n            </li>\n            <li>\n            Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\n            </li>\n        </ol>\n        </div>\n    ),\n    worstCase: (\n        <span>\n        O(<em>n</em>*log(<em>n</em>))\n        </span>\n    ),\n    avgCase: (\n        <span>\n        O(<em>n</em>*log(<em>n</em>))\n        </span>\n    ),\n    bestCase: (\n        <span>\n        O(<em>n</em>*log(<em>n</em>))\n        </span>\n    ),\n    space: (\n        <span>\n        O(<em>n</em>)\n        </span>\n    )\n}\n\nexport default MergeSort;"]},"metadata":{},"sourceType":"module"}